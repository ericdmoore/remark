/**
 * @typedef Options
 * @property {boolean} [gapless=false] Whether to filter out `null` and `undefined` results
 * @property {string} [key] If a key is given, and an object supplied to the wrapped `fn`, values at that object’s `key` field are mapped and the object, instead of the values, is given to `fn` as a last parameter. If a key is given and an array is passed to the wrapped `fn`, no value is given to `fn` as a last parameter
 */
/**
 * Functional map with sugar (functional, as values are provided as a parameter,
 * instead of context object).
 *
 * Wraps the supplied `fn`, which handles one value, so that it accepts multiple
 * values, calling `fn` for each and returning all results.
 *
 * If `options` is a string, it’s treated as `{key: options}`.
 *
 * @template {unknown} Value
 * @template {Value[]} Values
 * @param {(value: Value, parent: Values|Value?) => unknown} fn
 * @param {string|Options} [options]
 */
export function mapz<Value extends unknown, Values extends Value[]>(
  fn: (value: Value, parent: Value | Values) => unknown,
  options?: string | Options
): (values: Value | Values) => unknown[]
export type Options = {
  /**
   * Whether to filter out `null` and `undefined` results
   */
  gapless?: boolean
  /**
   * If a key is given, and an object supplied to the wrapped `fn`, values at that object’s `key` field are mapped and the object, instead of the values, is given to `fn` as a last parameter. If a key is given and an array is passed to the wrapped `fn`, no value is given to `fn` as a last parameter
   */
  key?: string
}
